#### 选择排序(SelectSort)
**算法思想**：每次(第i次)选择一个关键字最小的元素，作为有序子序列中的第i个元素，当数组元素只剩下一个时，排序结束。

时间复杂度：O(n2)  空间复杂度：O(1)

由于选择排序是从每一次中找出最小的元素的关键字(位置索引)，因此直接将arr[i]和arr[minIdx]进行交换即可，所以空间复杂度为O(1)。
同时，由于发生元素的交换，所以选择排序也是一种不稳定的排序算法。

[912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)
```
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        """
        选择排序 -- Time: O(n2)  Space: O(1)
        实现思路：每一次找到最小的元素，将该元素与nums[i]进行交换
        """
        # 注意循环执行到n-1个元素就可以终止了，最后一个元素有序
        for i in range(len(nums)):
            # minN用来记录最小元素的位置
            minN = i
            for j in range(i+1, len(nums)):
                if nums[minN] > nums[j]:
                    minN = j
            # 将minN位置元素与nums[i]进行交换
            nums[i], nums[minN] = nums[minN], nums[i]
        return nums
```

#### 堆排序(HeapSort)
**算法思想**：堆排序是一种**树形选择排序**方法。特点：将待排序序列视为一棵**完全二叉树**的顺序存储结构，利用完全二叉树中双亲节点和孩子节点
之间的内在关系，再当前无序区中选择关键字最大(或最小)的元素。

**堆的定义**：  
小根堆：L(i)<=L(2i) 且 L(i)<=L(2i+1)  (1<=i<= n//2)  
大根堆：L(i)>=L(2i) 且 L(i)>=L(2i+1)  (1<=i<= n//2)  

#### 堆排序算法：
堆排序算法的关键是**构建初始堆**，对初始序列建堆，是一个反复筛选的过程。其中，n个节点的完全二叉树，最后一个结点是第[n//2]个结点的孩子。  
**调整顺序**：从第[n//2]个结点为根的子树开始筛选，直到根节点为止。  
**调整过程(以大根堆为例)**: 对第[n//2]个结点为根的子树开始筛选，**若根节点的关键字小于左右孩子中关键字较大者，则交换**，使该子树成为
堆。之后依次向前对各结点([n//2]-1 ~ 1)为根的子树进行筛选，看该结点值是否大于其左右结点的值。若不大于，则将左右结点中的较大值与之交换。
**交换后可能会破坏下一级的堆，于是继续采用上述方法构建下一级的堆，直到以该结点为根的子树构成堆为止。**  
**重复以上调整过程，直到根结点。**

#### 时间复杂度和空间复杂度分析：
建堆时间复杂度为：O(n), 之后有n-1次向下调整操作，每次调整的时间复杂度为O(h) -- 其中h代表堆的高度， 因此在最好、最坏和平均情况下，堆
排序的时间复杂度为O(n+nlog2n), 即`O(nlog2n)`。  
空间复杂度为O(1), 仅使用了常数个辅助单元。这是因为堆排序是通过操作原数组使其满足堆的特征，是完全二叉树的数组表示。因此针对堆排序所进行
的操作都是在原数组上进行的，只额外需要常数个辅助单元。

#### 堆的插入和删除操作：
**删除操作**：由于堆顶元素为最大值或者为最小值，**删除堆顶元素时，先将堆的最后一个元素与堆顶元素交换，**此时，由于堆的性质被破坏，需要
对此时的根节点进行**向下调整操作**。  
**插入操作**：先**将新结点放在堆的末端**，再对这个新结点执行**向上调整操作**。

#### 堆的应用：堆经常被用来实现优先级队列，优先级队列常用于操作系统的作业调度和消息队列等