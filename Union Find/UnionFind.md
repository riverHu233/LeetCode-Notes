链接：https://leetcode-cn.com/leetbook/read/disjoint-set/ov6uks/  
来源：力扣（LeetCode），仅用于个人学习，侵删。

### 并查集(Union Find) -- 不相交集合(Disjoint Set)

用途： 专门用于 **动态处理** 不相交集合的查询和合并问题。

查询（Find）：查询图中的两个顶点是不是在同一个集合中。
注意：并查集只回答两个顶点之间是否有一条路径连接，而不回答怎么连接。

合并（Union）：将两个不相交集合进行合并。

quick-find：「基于 id」的思想给每一个元素（顶点）分配一个唯一标识，称为 id。

初始化的时候：所有元素的 id 都不一样，表示一个元素单独属于一个集合。
如果两个元素的 id 一样，标识它们同属于一个集合；
合并的时候，需要将其中一个集合中的 所有元素 的 id 赋值成为另一个集合的 id（一个集合中的所有元素的 id 均一样）。
类似于：给每个元素（顶点）改名字，名字一样，就表示在同一个集合中。

优点：查询两个元素是否在一个集合中很快，时间复杂度为 `O(1)`；
缺点：把两个集合合并成一个集合较慢，需要遍历其中一个集合中的所有元素。

quick-union：基于 parent（重要）
「基于 parent」的思想其实也很常见：记录每个顶点的父亲顶点是谁。这样设计「并查集」的思想也叫**「代表元」**法。

我们不再使用 id 数组，而使用 parent 数组。parent 数组的定义是：parent[i] 表示标识为 i 的结点的父亲结点的
标识（可以形象地记为「找爸爸」）。在这个定义下，根结点的父亲结点是自己。


「代表元」的「三个不重要」
以下「三个不重要」概括了「代表元法」的设计理念，大家需要结合练习体会。

+ 谁作为根结点不重要：根结点与非根结点只是位置不同，并没有附加的含义；
+ 树怎么形成的不重要：合并的时候任何一个集合的根结点指向另一个结合的根结点就可以；
+ 树的形态不重要：理由同「谁作为根结点不重要」。  

**代表元法可能造成的问题**：树的高度过高，查询性能降低。

[^_^]: 引用所展示的效果如下用法：>的个数决定了引用的层级，多级引用;同时本行也是注释的用法，注释信息之间不能有空格，否则无法隐藏

>知识扩展：几乎所有的「树」的问题都在和「树的高度」较劲：
>>「快速排序」，使用随机化 pivot 的方式避免递归树太深；  
>>「二叉搜索树」为了避免递归树太深，采用不同的旋转方式，得到了 AVL 树和红黑树。


解决方案有「按秩合并」与「路径压缩」，我们先介绍「按秩合并」。



#### 总结
---

可以使用「并查集」解决的问题，一般都可以使用「深度优先搜索」和「广度优先搜索」完成。
但是「深度优先搜索」和「广度优先搜索」不仅回答了连接问题，还回答了路径问题，时间复杂度高。

有一些问题恰恰好只需要我们回答连通性问题，这样的问题是应用「并查集」的典型问题。关于「并查集」我们总结如下：

+ 「并查集」使用了「代表元」的思想，用一个代表元表示同在一个集合中的所有的元素；
+ 「并查集」的底层是数组或者哈希表，记录了一个元素的直接父亲结点是谁，因此「并查集」是一种由子结点查询父结点的特殊树结构；
+  基于「代表元」的思想：「并查集」的「合并」操作：将一个集合的根结点指向一个集合的根结点；
+  在维护树的高度的时候，采用的「等价」的思想，在「合并」时使用了「按秩合并」优化，在「查询」时使用了「路径压缩」优化；
同时使用了「路径压缩」和「按秩合并」的时候，引发了广大计算机科学家的充分的讨论，从而诞生出了更多更有意思的问题。
